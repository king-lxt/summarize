### 1、数组去重

```·
 var arr = [1, 2, 3, 1, 2, 3, 6];
 const newArr = [];
 arr.filter((v, i, arr) => {
   if (arr.indexOf(v) === i) {
   newArr.push(v)
   }
 })
 console.log(newArr);
```

方法2

```
// 重用

let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];
console.log([...new Set(arr)]);
```

方法3：利用对象属性存在的特性，如果没有该属性则存入新数组。

```
Array.prototype.unique = function () {
    var arr = this, obj = {}, result = [];
    for (var i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) { //如果能查找到，证明数组元素重复了
            obj[arr[i]] = 1;
            result.push(arr[i]);
        }
    }
    return result;
};
var a = [1, 2, 3, 1, 2, 3];
var b = a.unique();
console.log(b); //打印结果：(3) [1, 2, 3]

```

### 2、深拷贝

```
function deepClone(obj) {
  if (typeof obj === 'object') {
    var result = obj.constructor === Array ? [] : {};
    for (let i in obj) {
    	result[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
    }
  } else {
  	var result = obj;
  }
  return result;
}
const a = {
  b: 1,
  c: [2, 34],
  d: {
  	i: 12,
  	j: [90, 100]
  }
}
const newObj = deepClone(a);
console.log("🚀 ~ file: index.html ~ line 31 ~ newObj", newObj)
```

### 3、防抖节流

防抖：触发高频函数事件后，n秒内函数只执行一次，如果n秒内这个事件再次被触发的话，那么重新计算时间。使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。
 节流：就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可

```
function debounce(func, wait) {
let timeout = null;
return function() {
  // 如果定时器存在的话，就清楚定时器
    if (timeout) clearTimeout(timeout);
      timeout = setTimeout(() => {
        func.apply(this, arguments)
    }, wait);
  }
}

// 节流
function throttle(func, timeout) {
  let timeout = null;
  return function() {
    if (!timeout) {
    	timeout = setTimeout(() => {
        timeout = null;
      }, wait);
    }
  }
}
```

### 4、call

```
// call

Function.prototype.call = function(context) {
    var context = context || window;
    context.fn = this;
    var args = [];
    var result;
    for (var i = 1; i < arguments.length; i++) {
        args.push(`arguments[${i}]`)
    }
    result = eval(`context.fn(${args})`)
    delete context.fn;
    return result;
}

或者

Function.prototype.call = function (context, ...args) {
  context = context || window;
  
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  context[fnSymbol](...args);
  delete context[fnSymbol];
}
```

### 5、Apply

```
// apply
Function.prototype.apply2 = function(context,arr){
    var context = Object(context) || window;
    context.fn = this;
    var args = [];
    var result;
    if(!arr){
        result = context.fn()
    }else{
        for(var i=0;i<arr.length;i++){
            args.push(`arr[${i}]`)
        }
        result = eval(`context.fn(${args})`)
    }
    delete context.fn;
    return result;
}

或者

Function.prototype.apply = function (context, argsArr) {
  context = context || window;
  
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  context[fnSymbol](...argsArr);
  delete context[fnSymbol];
}
```

### 6、bind

```
// bind

Function.prototype.bind = function (context, ...args) {
  context = context || window;
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  return function (..._args) {
    args = args.concat(_args);
    
    context[fnSymbol](...args);
    delete context[fnSymbol];   
  }
}

或者

Function.prototype.bind = function (context, ...args) {
  context = context || window;
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  return function (..._args) {
    args = args.concat(_args);
    
    context[fnSymbol](...args);
    delete context[fnSymbol];   
  }
}
```

7、手写promise

```
// 简易版
class MyPromise {
  constructor(fn) {
    this.resolvedCallbacks = [];
    this.rejectedCallbacks = [];
    
    this.state = 'PENDING';
    this.value = '';
    
    fn(this.resolve.bind(this), this.reject.bind(this));
    
  }
  
  resolve(value) {
    if (this.state === 'PENDING') {
      this.state = 'RESOLVED';
      this.value = value;
      
      this.resolvedCallbacks.map(cb => cb(value));   
    }
  }
  
  reject(value) {
    if (this.state === 'PENDING') {
      this.state = 'REJECTED';
      this.value = value;
      
      this.rejectedCallbacks.map(cb => cb(value));
    }
  }
  
  then(onFulfilled, onRejected) {
    if (this.state === 'PENDING') {
      this.resolvedCallbacks.push(onFulfilled);
      this.rejectedCallbacks.push(onRejected);
      
    }
    
    if (this.state === 'RESOLVED') {
      onFulfilled(this.value);
    }
    
    if (this.state === 'REJECTED') {
      onRejected(this.value);
    }
  }
}
      

```

